"use server"

import { Octokit } from "@octokit/rest"
import type { GeneratedFile } from "@/lib/file-parser"

interface GitHubPushResult {
  success: boolean
  repoUrl?: string
  error?: string
}

interface GitHubPushParams {
  token: string
  repoName: string
  description?: string
  isPrivate?: boolean
  files: GeneratedFile[]
}

export async function createRepoAndPushFiles({
  token,
  repoName,
  description = "Generated by Ralph Builder",
  isPrivate = false,
  files,
}: GitHubPushParams): Promise<GitHubPushResult> {
  try {
    const octokit = new Octokit({ auth: token })

    // Get authenticated user
    const { data: user } = await octokit.users.getAuthenticated()
    const owner = user.login

    // Sanitize repo name
    const sanitizedRepoName = repoName
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, "-")
      .replace(/-+/g, "-")
      .slice(0, 100)

    // Create repository
    let repoCreated = false
    try {
      await octokit.repos.createForAuthenticatedUser({
        name: sanitizedRepoName,
        description,
        private: isPrivate,
        auto_init: true, // Creates with README so we have a commit to build on
      })
      repoCreated = true
      // Wait for repo to be ready
      await new Promise((resolve) => setTimeout(resolve, 2000))
    } catch (err: unknown) {
      const error = err as { status?: number }
      if (error.status === 422) {
        // Repo already exists, we'll push to it
        repoCreated = false
      } else {
        throw err
      }
    }

    // Get the default branch ref
    const { data: ref } = await octokit.git.getRef({
      owner,
      repo: sanitizedRepoName,
      ref: "heads/main",
    })

    const currentCommitSha = ref.object.sha

    // Get the current commit to get its tree
    const { data: currentCommit } = await octokit.git.getCommit({
      owner,
      repo: sanitizedRepoName,
      commit_sha: currentCommitSha,
    })

    // Create blobs for all files
    const blobs = await Promise.all(
      files.map(async (file) => {
        const { data } = await octokit.git.createBlob({
          owner,
          repo: sanitizedRepoName,
          content: Buffer.from(file.content).toString("base64"),
          encoding: "base64",
        })
        return { path: file.path, sha: data.sha }
      }),
    )

    // Create a new tree with all files
    const { data: newTree } = await octokit.git.createTree({
      owner,
      repo: sanitizedRepoName,
      base_tree: currentCommit.tree.sha,
      tree: blobs.map((blob) => ({
        path: blob.path,
        mode: "100644" as const,
        type: "blob" as const,
        sha: blob.sha,
      })),
    })

    // Create the commit
    const { data: newCommit } = await octokit.git.createCommit({
      owner,
      repo: sanitizedRepoName,
      message: repoCreated ? "Initial commit from Ralph Builder" : "Update from Ralph Builder",
      tree: newTree.sha,
      parents: [currentCommitSha],
    })

    // Update the reference to point to the new commit
    await octokit.git.updateRef({
      owner,
      repo: sanitizedRepoName,
      ref: "heads/main",
      sha: newCommit.sha,
    })

    return {
      success: true,
      repoUrl: `https://github.com/${owner}/${sanitizedRepoName}`,
    }
  } catch (err: unknown) {
    console.error("GitHub push error:", err)
    const error = err as { message?: string }
    return {
      success: false,
      error: error.message || "Failed to push to GitHub",
    }
  }
}

// Validate a GitHub token
export async function validateGitHubToken(token: string): Promise<{
  valid: boolean
  username?: string
  error?: string
}> {
  try {
    const octokit = new Octokit({ auth: token })
    const { data: user } = await octokit.users.getAuthenticated()
    return { valid: true, username: user.login }
  } catch {
    return { valid: false, error: "Invalid or expired token" }
  }
}
